# DesignPatterns

##### 디자인 원칙 #####
1. 구현이 아닌 인터페이스에 맞춰서 프로그래밍한다.
2. 상속보다는 구성을 활용한다.
3. 서로 상호작용을 하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인을 사용해야 한다.
4. 클래스는 확장에 대해서는 열려 있어야 하지만 코드 변경에 대해서는 닫혀 있어야 한다.
5. 추상화된 것에 의존하도록 만든다. 구상 클래스에 의존하도록 만들지 않도록 한다.
6. 최소 지식 원칙 - 어떤 객체든 그 객체와 상호작용을 하는 클래스의 개수에 주의해야 하며, 그런 객체들과 어떤 식으로 상호작용을 하는지에도 주의를 기울여야 한다.
7. 클래스를 바꾸는 이유는 한 가지 뿐이어야 한다.

## 1. Strategy Pattern
  - 알고리즘군을 정의하고 각각을 캡슐화하여 교환해서 사용할 수 있도록 만든다.
  - Strategy를 활용하면 알고리즘을 사용하는 클라이언트와는 독립적으로 알고리즘을 변경 할 수 있다.
## 2. Observer Pattern
  - 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다(one-to-many) 의존성을 정의한다.
## 3. Decorator Pattern
  - 객체에 추가 요소를 동적으로 더할 수 있다.
  - 데코레이터를 사용하면 서브 클래스를 만드는 경우에 비해 훨씬 유연하게 기능을 확장할 수 있다.
## 4. Factory Method Pattern
  - 팩토리 메소드 패턴에서는 객체를 생성하기 위한 인터페이스를  어떤 클래스의 인스턴스를 만들지는 서브클래에서 결정하게 만든다.
  - 팩토리 메소드 패턴을 이용하면 클래스의 인스턴스를 만드는 일을 서브클래스에게 맡길 수 있다.
## 5. Singleton Pattern
  - 싱글톤 패턴은 해당 클래스의 인스턴스가 하나만 만들어지고, 어디서든지 그 인스턴스에 접근할 수 있도록 하기 위한 패턴.
## 6. Command Pattern
  - 커맨드 패턴을 이용하면 요구 사항을 객체로 캡슐화 할 수 있으며, 매개변수를 써서 여러 가지 다른 요구 사항을 집어넣을 수 있다.
  - 요청 내역을 큐에 저장하거나 로그로 기록할 수도 작업 취소 기능도 지원 가능하다.
## 7. Adapter Pattern
  - 한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환한다.
  - 어댑터를 이용하면 인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수 있다.
## 8. Facade Pattern
  - 어떤 서브시스템의 일련의 인터페이스에 대한 통합된 인터페이스를 제공한다.
  - 고수준 인터페이스를 정의하기 때문에 서브시스템을 더 쉽게 사용할 수 있다.
## 9. Template Method Pattern
  - 어떤 작업 알고리즘의 골격을 정의한다. 일부 단계는 서브클래스에서 구현하도록 할 수 있다.
  - 템플릿 메소드를 이용하면 알고리즘의 구조는 그대로 유지하면서 특정 단계만 서브클래스에서 새로 정의하도록 할 수 있다.
## 10. Iterator Pattern
  - 컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 접근할 수 있게 해 주는 방법을 제공.
## 11. Composite Pattern
  - 객체들을 트리 구조로 구성하여 부분과 전체를 나타내는 계층구조로 만들 수 있다.
  - 클라이언트에서 개별 객체와 다른 객체들로 구성된 복합 객체를 똑같은 방법으로 다룰 수 있다.
